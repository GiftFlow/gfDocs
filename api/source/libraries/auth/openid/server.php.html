<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="PHPDoctor 2RC4 (http://peej.github.com/phpdoctor/)">
<meta name="when" content="Wed, 09 Feb 2011 20:22:56 +0000">

<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css">
<link rel="start" href="../../../../overview-summary.html">

<title>libraries/Auth/OpenID/Server.php (GiftFlow API)</title>

</head>
<body id="file" onload="parent.document.title=document.title;">

<div class="header">
<h1>GiftFlow API</h1>
<ul>
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../../../../overview-files.html">Files</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../../../../index.html" target="_top">Frames</a>
<a href="../../../../source/libraries/auth/openid/server.php.html" target="_top">No frames</a>
</div>
<hr>

<h1>libraries/Auth/OpenID/Server.php</h1>
<div class="comment" id="overview_description"><p>OpenID server protocol and logic.</p><p>Overview</p><p>An OpenID server must perform three tasks:</p><p>1. Examine the incoming request to determine its nature and validity.
2. Make a decision about how to respond to this request.
3. Format the response according to the protocol.</p><p>The first and last of these tasks may performed by the  and  methods.  Who gets to do the
intermediate task -- deciding how to respond to the request -- will
depend on what type of request it is.</p><p>If it's a request to authenticate a user (a 'checkid_setup' or
'checkid_immediate' request), you need to decide if you will assert
that this user may claim the identity in question.  Exactly how you
do that is a matter of application policy, but it generally
involves making sure the user has an account with your system and
is logged in, checking to see if that identity is hers to claim,
and verifying with the user that she does consent to releasing that
information to the party making the request.</p><p>Examine the properties of the <code>Auth_OpenID_CheckIDRequest</code>
object, and if and when you've come to a decision, form a response
by calling <code>Auth_OpenID_CheckIDRequest::answer()</code>.</p><p>Other types of requests relate to establishing associations between
client and server and verifing the authenticity of previous
communications.  <code>Auth_OpenID_Server</code> contains all the logic
and data necessary to respond to such requests; just pass it to
<code>Auth_OpenID_Server::handleRequest()</code>.</p><p>OpenID Extensions</p><p>Do you want to provide other information for your users in addition
to authentication?  Version 1.2 of the OpenID protocol allows
consumers to add extensions to their requests.  For example, with
sites using the Simple Registration
Extension
(http://openid.net/specs/openid-simple-registration-extension-1_0.html),
a user can agree to have their nickname and e-mail address sent to
a site when they sign up.</p><p>Since extensions do not change the way OpenID authentication works,
code to handle extension requests may be completely separate from
the <code>Auth_OpenID_Request</code> class here.  But you'll likely want
data sent back by your extension to be signed.   provides methods with which you can add
data to it which can be signed with the other data in the OpenID
signature.</p><p>For example:</p><p><pre>  // when request is a checkid_* request
$response = $request->answer(true);
this will a signed 'openid.sreg.timezone' parameter to the response
response.addField('sreg', 'timezone', 'America/Los_Angeles')</pre></p><p>Stores</p><p>The OpenID server needs to maintain state between requests in order
to function.  Its mechanism for doing this is called a store.  The
store interface is defined in Interface.php.  Additionally, several
concrete store implementations are provided, so that most sites
won't need to implement a custom store.  For a store backed by flat
files on disk, see <code>Auth_OpenID_FileStore</code>.  For stores based
on MySQL, SQLite, or PostgreSQL, see the  subclasses.</p><p>Upgrading</p><p>The keys by which a server looks up associations in its store have
changed in version 1.2 of this library.  If your store has entries
created from version 1.0 code, you should empty it.</p><p>PHP versions 4 and 5</p><p>LICENSE: See the COPYING file included in this distribution.</p></div>

<hr>

<a name="line1"></a><pre><?php
<a name="line2"></a>
<a name="line3"></a>/**
<a name="line4"></a> * OpenID server protocol and logic.
<a name="line5"></a> * 
<a name="line6"></a> * Overview
<a name="line7"></a> *
<a name="line8"></a> * An OpenID server must perform three tasks:
<a name="line9"></a> *
<a name="line10"></a> *  1. Examine the incoming request to determine its nature and validity.
<a name="line11"></a> *  2. Make a decision about how to respond to this request.
<a name="line12"></a> *  3. Format the response according to the protocol.
<a name="line13"></a> * 
<a name="line14"></a> * The first and last of these tasks may performed by the {@link
<a name="line15"></a> * Auth_OpenID_Server::decodeRequest()} and {@link
<a name="line16"></a> * Auth_OpenID_Server::encodeResponse} methods.  Who gets to do the
<a name="line17"></a> * intermediate task -- deciding how to respond to the request -- will
<a name="line18"></a> * depend on what type of request it is.
<a name="line19"></a> *
<a name="line20"></a> * If it's a request to authenticate a user (a 'checkid_setup' or
<a name="line21"></a> * 'checkid_immediate' request), you need to decide if you will assert
<a name="line22"></a> * that this user may claim the identity in question.  Exactly how you
<a name="line23"></a> * do that is a matter of application policy, but it generally
<a name="line24"></a> * involves making sure the user has an account with your system and
<a name="line25"></a> * is logged in, checking to see if that identity is hers to claim,
<a name="line26"></a> * and verifying with the user that she does consent to releasing that
<a name="line27"></a> * information to the party making the request.
<a name="line28"></a> *
<a name="line29"></a> * Examine the properties of the {@link Auth_OpenID_CheckIDRequest}
<a name="line30"></a> * object, and if and when you've come to a decision, form a response
<a name="line31"></a> * by calling {@link Auth_OpenID_CheckIDRequest::answer()}.
<a name="line32"></a> *
<a name="line33"></a> * Other types of requests relate to establishing associations between
<a name="line34"></a> * client and server and verifing the authenticity of previous
<a name="line35"></a> * communications.  {@link Auth_OpenID_Server} contains all the logic
<a name="line36"></a> * and data necessary to respond to such requests; just pass it to
<a name="line37"></a> * {@link Auth_OpenID_Server::handleRequest()}.
<a name="line38"></a> *
<a name="line39"></a> * OpenID Extensions
<a name="line40"></a> * 
<a name="line41"></a> * Do you want to provide other information for your users in addition
<a name="line42"></a> * to authentication?  Version 1.2 of the OpenID protocol allows
<a name="line43"></a> * consumers to add extensions to their requests.  For example, with
<a name="line44"></a> * sites using the Simple Registration
<a name="line45"></a> * Extension
<a name="line46"></a> * (http://openid.net/specs/openid-simple-registration-extension-1_0.html),
<a name="line47"></a> * a user can agree to have their nickname and e-mail address sent to
<a name="line48"></a> * a site when they sign up.
<a name="line49"></a> *
<a name="line50"></a> * Since extensions do not change the way OpenID authentication works,
<a name="line51"></a> * code to handle extension requests may be completely separate from
<a name="line52"></a> * the {@link Auth_OpenID_Request} class here.  But you'll likely want
<a name="line53"></a> * data sent back by your extension to be signed.  {@link
<a name="line54"></a> * Auth_OpenID_ServerResponse} provides methods with which you can add
<a name="line55"></a> * data to it which can be signed with the other data in the OpenID
<a name="line56"></a> * signature.
<a name="line57"></a> *
<a name="line58"></a> * For example:
<a name="line59"></a> *
<a name="line60"></a> * <pre>  // when request is a checkid_* request
<a name="line61"></a> *  $response = $request->answer(true);
<a name="line62"></a> *  // this will a signed 'openid.sreg.timezone' parameter to the response
<a name="line63"></a> *  response.addField('sreg', 'timezone', 'America/Los_Angeles')</pre>
<a name="line64"></a> *
<a name="line65"></a> * Stores
<a name="line66"></a> *
<a name="line67"></a> * The OpenID server needs to maintain state between requests in order
<a name="line68"></a> * to function.  Its mechanism for doing this is called a store.  The
<a name="line69"></a> * store interface is defined in Interface.php.  Additionally, several
<a name="line70"></a> * concrete store implementations are provided, so that most sites
<a name="line71"></a> * won't need to implement a custom store.  For a store backed by flat
<a name="line72"></a> * files on disk, see {@link Auth_OpenID_FileStore}.  For stores based
<a name="line73"></a> * on MySQL, SQLite, or PostgreSQL, see the {@link
<a name="line74"></a> * Auth_OpenID_SQLStore} subclasses.
<a name="line75"></a> *
<a name="line76"></a> * Upgrading
<a name="line77"></a> *
<a name="line78"></a> * The keys by which a server looks up associations in its store have
<a name="line79"></a> * changed in version 1.2 of this library.  If your store has entries
<a name="line80"></a> * created from version 1.0 code, you should empty it.
<a name="line81"></a> *
<a name="line82"></a> * PHP versions 4 and 5
<a name="line83"></a> *
<a name="line84"></a> * LICENSE: See the COPYING file included in this distribution.
<a name="line85"></a> *
<a name="line86"></a> * @package OpenID
<a name="line87"></a> * @author JanRain, Inc. <openid@janrain.com>
<a name="line88"></a> * @copyright 2005-2008 Janrain, Inc.
<a name="line89"></a> * @license http://www.apache.org/licenses/LICENSE-2.0 Apache
<a name="line90"></a> */
<a name="line91"></a>
<a name="line92"></a>/**
<a name="line93"></a> * Required imports
<a name="line94"></a> */
<a name="line95"></a>require_once "Auth/OpenID.php";
<a name="line96"></a>require_once "Auth/OpenID/Association.php";
<a name="line97"></a>require_once "Auth/OpenID/CryptUtil.php";
<a name="line98"></a>require_once "Auth/OpenID/BigMath.php";
<a name="line99"></a>require_once "Auth/OpenID/DiffieHellman.php";
<a name="line100"></a>require_once "Auth/OpenID/KVForm.php";
<a name="line101"></a>require_once "Auth/OpenID/TrustRoot.php";
<a name="line102"></a>require_once "Auth/OpenID/ServerRequest.php";
<a name="line103"></a>require_once "Auth/OpenID/Message.php";
<a name="line104"></a>require_once "Auth/OpenID/Nonce.php";
<a name="line105"></a>
<a name="line106"></a>define('AUTH_OPENID_HTTP_OK', 200);
<a name="line107"></a>define('AUTH_OPENID_HTTP_REDIRECT', 302);
<a name="line108"></a>define('AUTH_OPENID_HTTP_ERROR', 400);
<a name="line109"></a>
<a name="line110"></a>/**
<a name="line111"></a> * @access private
<a name="line112"></a> */
<a name="line113"></a>global $_Auth_OpenID_Request_Modes;
<a name="line114"></a>$_Auth_OpenID_Request_Modes = array('checkid_setup',
<a name="line115"></a>                                    'checkid_immediate');
<a name="line116"></a>
<a name="line117"></a>/**
<a name="line118"></a> * @access private
<a name="line119"></a> */
<a name="line120"></a>define('Auth_OpenID_ENCODE_KVFORM', 'kfvorm');
<a name="line121"></a>
<a name="line122"></a>/**
<a name="line123"></a> * @access private
<a name="line124"></a> */
<a name="line125"></a>define('Auth_OpenID_ENCODE_URL', 'URL/redirect');
<a name="line126"></a>
<a name="line127"></a>/**
<a name="line128"></a> * @access private
<a name="line129"></a> */
<a name="line130"></a>define('Auth_OpenID_ENCODE_HTML_FORM', 'HTML form');
<a name="line131"></a>
<a name="line132"></a>/**
<a name="line133"></a> * @access private
<a name="line134"></a> */
<a name="line135"></a>function Auth_OpenID_isError($obj, $cls = 'Auth_OpenID_ServerError')
<a name="line136"></a>{
<a name="line137"></a>    return is_a($obj, $cls);
<a name="line138"></a>}
<a name="line139"></a>
<a name="line140"></a>/**
<a name="line141"></a> * An error class which gets instantiated and returned whenever an
<a name="line142"></a> * OpenID protocol error occurs.  Be prepared to use this in place of
<a name="line143"></a> * an ordinary server response.
<a name="line144"></a> *
<a name="line145"></a> * @package OpenID
<a name="line146"></a> */
<a name="line147"></a>class Auth_OpenID_ServerError {
<a name="line148"></a>    /**
<a name="line149"></a>     * @access private
<a name="line150"></a>     */
<a name="line151"></a>    function Auth_OpenID_ServerError($message = null, $text = null,
<a name="line152"></a>                                     $reference = null, $contact = null)
<a name="line153"></a>    {
<a name="line154"></a>        $this->message = $message;
<a name="line155"></a>        $this->text = $text;
<a name="line156"></a>        $this->contact = $contact;
<a name="line157"></a>        $this->reference = $reference;
<a name="line158"></a>    }
<a name="line159"></a>
<a name="line160"></a>    function getReturnTo()
<a name="line161"></a>    {
<a name="line162"></a>        if ($this->message &&
<a name="line163"></a>            $this->message->hasKey(Auth_OpenID_OPENID_NS, 'return_to')) {
<a name="line164"></a>            return $this->message->getArg(Auth_OpenID_OPENID_NS,
<a name="line165"></a>                                          'return_to');
<a name="line166"></a>        } else {
<a name="line167"></a>            return null;
<a name="line168"></a>        }
<a name="line169"></a>    }
<a name="line170"></a>
<a name="line171"></a>    /**
<a name="line172"></a>     * Returns the return_to URL for the request which caused this
<a name="line173"></a>     * error.
<a name="line174"></a>     */
<a name="line175"></a>    function hasReturnTo()
<a name="line176"></a>    {
<a name="line177"></a>        return $this->getReturnTo() !== null;
<a name="line178"></a>    }
<a name="line179"></a>
<a name="line180"></a>    /**
<a name="line181"></a>     * Encodes this error's response as a URL suitable for
<a name="line182"></a>     * redirection.  If the response has no return_to, another
<a name="line183"></a>     * Auth_OpenID_ServerError is returned.
<a name="line184"></a>     */
<a name="line185"></a>    function encodeToURL()
<a name="line186"></a>    {
<a name="line187"></a>        if (!$this->message) {
<a name="line188"></a>            return null;
<a name="line189"></a>        }
<a name="line190"></a>
<a name="line191"></a>        $msg = $this->toMessage();
<a name="line192"></a>        return $msg->toURL($this->getReturnTo());
<a name="line193"></a>    }
<a name="line194"></a>
<a name="line195"></a>    /**
<a name="line196"></a>     * Encodes the response to key-value form.  This is a
<a name="line197"></a>     * machine-readable format used to respond to messages which came
<a name="line198"></a>     * directly from the consumer and not through the user-agent.  See
<a name="line199"></a>     * the OpenID specification.
<a name="line200"></a>     */
<a name="line201"></a>    function encodeToKVForm()
<a name="line202"></a>    {
<a name="line203"></a>        return Auth_OpenID_KVForm::fromArray(
<a name="line204"></a>                                      array('mode' => 'error',
<a name="line205"></a>                                            'error' => $this->toString()));
<a name="line206"></a>    }
<a name="line207"></a>
<a name="line208"></a>    function toFormMarkup($form_tag_attrs=null)
<a name="line209"></a>    {
<a name="line210"></a>        $msg = $this->toMessage();
<a name="line211"></a>        return $msg->toFormMarkup($this->getReturnTo(), $form_tag_attrs);
<a name="line212"></a>    }
<a name="line213"></a>
<a name="line214"></a>    function toHTML($form_tag_attrs=null)
<a name="line215"></a>    {
<a name="line216"></a>        return Auth_OpenID::autoSubmitHTML(
<a name="line217"></a>                      $this->toFormMarkup($form_tag_attrs));
<a name="line218"></a>    }
<a name="line219"></a>
<a name="line220"></a>    function toMessage()
<a name="line221"></a>    {
<a name="line222"></a>        // Generate a Message object for sending to the relying party,
<a name="line223"></a>        // after encoding.
<a name="line224"></a>        $namespace = $this->message->getOpenIDNamespace();
<a name="line225"></a>        $reply = new Auth_OpenID_Message($namespace);
<a name="line226"></a>        $reply->setArg(Auth_OpenID_OPENID_NS, 'mode', 'error');
<a name="line227"></a>        $reply->setArg(Auth_OpenID_OPENID_NS, 'error', $this->toString());
<a name="line228"></a>
<a name="line229"></a>        if ($this->contact !== null) {
<a name="line230"></a>            $reply->setArg(Auth_OpenID_OPENID_NS, 'contact', $this->contact);
<a name="line231"></a>        }
<a name="line232"></a>
<a name="line233"></a>        if ($this->reference !== null) {
<a name="line234"></a>            $reply->setArg(Auth_OpenID_OPENID_NS, 'reference',
<a name="line235"></a>                           $this->reference);
<a name="line236"></a>        }
<a name="line237"></a>
<a name="line238"></a>        return $reply;
<a name="line239"></a>    }
<a name="line240"></a>
<a name="line241"></a>    /**
<a name="line242"></a>     * Returns one of Auth_OpenID_ENCODE_URL,
<a name="line243"></a>     * Auth_OpenID_ENCODE_KVFORM, or null, depending on the type of
<a name="line244"></a>     * encoding expected for this error's payload.
<a name="line245"></a>     */
<a name="line246"></a>    function whichEncoding()
<a name="line247"></a>    {
<a name="line248"></a>        global $_Auth_OpenID_Request_Modes;
<a name="line249"></a>
<a name="line250"></a>        if ($this->hasReturnTo()) {
<a name="line251"></a>            if ($this->message->isOpenID2() &&
<a name="line252"></a>                (strlen($this->encodeToURL()) >
<a name="line253"></a>                   Auth_OpenID_OPENID1_URL_LIMIT)) {
<a name="line254"></a>                return Auth_OpenID_ENCODE_HTML_FORM;
<a name="line255"></a>            } else {
<a name="line256"></a>                return Auth_OpenID_ENCODE_URL;
<a name="line257"></a>            }
<a name="line258"></a>        }
<a name="line259"></a>
<a name="line260"></a>        if (!$this->message) {
<a name="line261"></a>            return null;
<a name="line262"></a>        }
<a name="line263"></a>
<a name="line264"></a>        $mode = $this->message->getArg(Auth_OpenID_OPENID_NS,
<a name="line265"></a>                                       'mode');
<a name="line266"></a>
<a name="line267"></a>        if ($mode) {
<a name="line268"></a>            if (!in_array($mode, $_Auth_OpenID_Request_Modes)) {
<a name="line269"></a>                return Auth_OpenID_ENCODE_KVFORM;
<a name="line270"></a>            }
<a name="line271"></a>        }
<a name="line272"></a>        return null;
<a name="line273"></a>    }
<a name="line274"></a>
<a name="line275"></a>    /**
<a name="line276"></a>     * Returns this error message.
<a name="line277"></a>     */
<a name="line278"></a>    function toString()
<a name="line279"></a>    {
<a name="line280"></a>        if ($this->text) {
<a name="line281"></a>            return $this->text;
<a name="line282"></a>        } else {
<a name="line283"></a>            return get_class($this) . " error";
<a name="line284"></a>        }
<a name="line285"></a>    }
<a name="line286"></a>}
<a name="line287"></a>
<a name="line288"></a>/**
<a name="line289"></a> * Error returned by the server code when a return_to is absent from a
<a name="line290"></a> * request.
<a name="line291"></a> *
<a name="line292"></a> * @package OpenID
<a name="line293"></a> */
<a name="line294"></a>class Auth_OpenID_NoReturnToError extends Auth_OpenID_ServerError {
<a name="line295"></a>    function Auth_OpenID_NoReturnToError($message = null,
<a name="line296"></a>                                         $text = "No return_to URL available")
<a name="line297"></a>    {
<a name="line298"></a>        parent::Auth_OpenID_ServerError($message, $text);
<a name="line299"></a>    }
<a name="line300"></a>
<a name="line301"></a>    function toString()
<a name="line302"></a>    {
<a name="line303"></a>        return "No return_to available";
<a name="line304"></a>    }
<a name="line305"></a>}
<a name="line306"></a>
<a name="line307"></a>/**
<a name="line308"></a> * An error indicating that the return_to URL is malformed.
<a name="line309"></a> *
<a name="line310"></a> * @package OpenID
<a name="line311"></a> */
<a name="line312"></a>class Auth_OpenID_MalformedReturnURL extends Auth_OpenID_ServerError {
<a name="line313"></a>    function Auth_OpenID_MalformedReturnURL($message, $return_to)
<a name="line314"></a>    {
<a name="line315"></a>        $this->return_to = $return_to;
<a name="line316"></a>        parent::Auth_OpenID_ServerError($message, "malformed return_to URL");
<a name="line317"></a>    }
<a name="line318"></a>}
<a name="line319"></a>
<a name="line320"></a>/**
<a name="line321"></a> * This error is returned when the trust_root value is malformed.
<a name="line322"></a> *
<a name="line323"></a> * @package OpenID
<a name="line324"></a> */
<a name="line325"></a>class Auth_OpenID_MalformedTrustRoot extends Auth_OpenID_ServerError {
<a name="line326"></a>    function Auth_OpenID_MalformedTrustRoot($message = null,
<a name="line327"></a>                                            $text = "Malformed trust root")
<a name="line328"></a>    {
<a name="line329"></a>        parent::Auth_OpenID_ServerError($message, $text);
<a name="line330"></a>    }
<a name="line331"></a>
<a name="line332"></a>    function toString()
<a name="line333"></a>    {
<a name="line334"></a>        return "Malformed trust root";
<a name="line335"></a>    }
<a name="line336"></a>}
<a name="line337"></a>
<a name="line338"></a>/**
<a name="line339"></a> * The base class for all server request classes.
<a name="line340"></a> *
<a name="line341"></a> * @package OpenID
<a name="line342"></a> */
<a name="line343"></a>class Auth_OpenID_Request {
<a name="line344"></a>    var $mode = null;
<a name="line345"></a>}
<a name="line346"></a>
<a name="line347"></a>/**
<a name="line348"></a> * A request to verify the validity of a previous response.
<a name="line349"></a> *
<a name="line350"></a> * @package OpenID
<a name="line351"></a> */
<a name="line352"></a>class Auth_OpenID_CheckAuthRequest extends Auth_OpenID_Request {
<a name="line353"></a>    var $mode = "check_authentication";
<a name="line354"></a>    var $invalidate_handle = null;
<a name="line355"></a>
<a name="line356"></a>    function Auth_OpenID_CheckAuthRequest($assoc_handle, $signed,
<a name="line357"></a>                                          $invalidate_handle = null)
<a name="line358"></a>    {
<a name="line359"></a>        $this->assoc_handle = $assoc_handle;
<a name="line360"></a>        $this->signed = $signed;
<a name="line361"></a>        if ($invalidate_handle !== null) {
<a name="line362"></a>            $this->invalidate_handle = $invalidate_handle;
<a name="line363"></a>        }
<a name="line364"></a>        $this->namespace = Auth_OpenID_OPENID2_NS;
<a name="line365"></a>        $this->message = null;
<a name="line366"></a>    }
<a name="line367"></a>
<a name="line368"></a>    static function fromMessage($message, $server=null)
<a name="line369"></a>    {
<a name="line370"></a>        $required_keys = array('assoc_handle', 'sig', 'signed');
<a name="line371"></a>
<a name="line372"></a>        foreach ($required_keys as $k) {
<a name="line373"></a>            if (!$message->getArg(Auth_OpenID_OPENID_NS, $k)) {
<a name="line374"></a>                return new Auth_OpenID_ServerError($message,
<a name="line375"></a>                    sprintf("%s request missing required parameter %s from \
<a name="line376"></a>                            query", "check_authentication", $k));
<a name="line377"></a>            }
<a name="line378"></a>        }
<a name="line379"></a>
<a name="line380"></a>        $assoc_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle');
<a name="line381"></a>        $sig = $message->getArg(Auth_OpenID_OPENID_NS, 'sig');
<a name="line382"></a>
<a name="line383"></a>        $signed_list = $message->getArg(Auth_OpenID_OPENID_NS, 'signed');
<a name="line384"></a>        $signed_list = explode(",", $signed_list);
<a name="line385"></a>
<a name="line386"></a>        $signed = $message;
<a name="line387"></a>        if ($signed->hasKey(Auth_OpenID_OPENID_NS, 'mode')) {
<a name="line388"></a>            $signed->setArg(Auth_OpenID_OPENID_NS, 'mode', 'id_res');
<a name="line389"></a>        }
<a name="line390"></a>
<a name="line391"></a>        $result = new Auth_OpenID_CheckAuthRequest($assoc_handle, $signed);
<a name="line392"></a>        $result->message = $message;
<a name="line393"></a>        $result->sig = $sig;
<a name="line394"></a>        $result->invalidate_handle = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line395"></a>                                                      'invalidate_handle');
<a name="line396"></a>        return $result;
<a name="line397"></a>    }
<a name="line398"></a>
<a name="line399"></a>    function answer($signatory)
<a name="line400"></a>    {
<a name="line401"></a>        $is_valid = $signatory->verify($this->assoc_handle, $this->signed);
<a name="line402"></a>
<a name="line403"></a>        // Now invalidate that assoc_handle so it this checkAuth
<a name="line404"></a>        // message cannot be replayed.
<a name="line405"></a>        $signatory->invalidate($this->assoc_handle, true);
<a name="line406"></a>        $response = new Auth_OpenID_ServerResponse($this);
<a name="line407"></a>
<a name="line408"></a>        $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line409"></a>                                  'is_valid',
<a name="line410"></a>                                  ($is_valid ? "true" : "false"));
<a name="line411"></a>
<a name="line412"></a>        if ($this->invalidate_handle) {
<a name="line413"></a>            $assoc = $signatory->getAssociation($this->invalidate_handle,
<a name="line414"></a>                                                false);
<a name="line415"></a>            if (!$assoc) {
<a name="line416"></a>                $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line417"></a>                                          'invalidate_handle',
<a name="line418"></a>                                          $this->invalidate_handle);
<a name="line419"></a>            }
<a name="line420"></a>        }
<a name="line421"></a>        return $response;
<a name="line422"></a>    }
<a name="line423"></a>}
<a name="line424"></a>
<a name="line425"></a>/**
<a name="line426"></a> * A class implementing plaintext server sessions.
<a name="line427"></a> *
<a name="line428"></a> * @package OpenID
<a name="line429"></a> */
<a name="line430"></a>class Auth_OpenID_PlainTextServerSession {
<a name="line431"></a>    /**
<a name="line432"></a>     * An object that knows how to handle association requests with no
<a name="line433"></a>     * session type.
<a name="line434"></a>     */
<a name="line435"></a>    var $session_type = 'no-encryption';
<a name="line436"></a>    var $needs_math = false;
<a name="line437"></a>    var $allowed_assoc_types = array('HMAC-SHA1', 'HMAC-SHA256');
<a name="line438"></a>
<a name="line439"></a>    static function fromMessage($unused_request)
<a name="line440"></a>    {
<a name="line441"></a>        return new Auth_OpenID_PlainTextServerSession();
<a name="line442"></a>    }
<a name="line443"></a>
<a name="line444"></a>    function answer($secret)
<a name="line445"></a>    {
<a name="line446"></a>        return array('mac_key' => base64_encode($secret));
<a name="line447"></a>    }
<a name="line448"></a>}
<a name="line449"></a>
<a name="line450"></a>/**
<a name="line451"></a> * A class implementing DH-SHA1 server sessions.
<a name="line452"></a> *
<a name="line453"></a> * @package OpenID
<a name="line454"></a> */
<a name="line455"></a>class Auth_OpenID_DiffieHellmanSHA1ServerSession {
<a name="line456"></a>    /**
<a name="line457"></a>     * An object that knows how to handle association requests with
<a name="line458"></a>     * the Diffie-Hellman session type.
<a name="line459"></a>     */
<a name="line460"></a>
<a name="line461"></a>    var $session_type = 'DH-SHA1';
<a name="line462"></a>    var $needs_math = true;
<a name="line463"></a>    var $allowed_assoc_types = array('HMAC-SHA1');
<a name="line464"></a>    var $hash_func = 'Auth_OpenID_SHA1';
<a name="line465"></a>
<a name="line466"></a>    function Auth_OpenID_DiffieHellmanSHA1ServerSession($dh, $consumer_pubkey)
<a name="line467"></a>    {
<a name="line468"></a>        $this->dh = $dh;
<a name="line469"></a>        $this->consumer_pubkey = $consumer_pubkey;
<a name="line470"></a>    }
<a name="line471"></a>
<a name="line472"></a>    static function getDH($message)
<a name="line473"></a>    {
<a name="line474"></a>        $dh_modulus = $message->getArg(Auth_OpenID_OPENID_NS, 'dh_modulus');
<a name="line475"></a>        $dh_gen = $message->getArg(Auth_OpenID_OPENID_NS, 'dh_gen');
<a name="line476"></a>
<a name="line477"></a>        if ((($dh_modulus === null) && ($dh_gen !== null)) ||
<a name="line478"></a>            (($dh_gen === null) && ($dh_modulus !== null))) {
<a name="line479"></a>
<a name="line480"></a>            if ($dh_modulus === null) {
<a name="line481"></a>                $missing = 'modulus';
<a name="line482"></a>            } else {
<a name="line483"></a>                $missing = 'generator';
<a name="line484"></a>            }
<a name="line485"></a>
<a name="line486"></a>            return new Auth_OpenID_ServerError($message,
<a name="line487"></a>                                'If non-default modulus or generator is '.
<a name="line488"></a>                                'supplied, both must be supplied.  Missing '.
<a name="line489"></a>                                $missing);
<a name="line490"></a>        }
<a name="line491"></a>
<a name="line492"></a>        $lib = Auth_OpenID_getMathLib();
<a name="line493"></a>
<a name="line494"></a>        if ($dh_modulus || $dh_gen) {
<a name="line495"></a>            $dh_modulus = $lib->base64ToLong($dh_modulus);
<a name="line496"></a>            $dh_gen = $lib->base64ToLong($dh_gen);
<a name="line497"></a>            if ($lib->cmp($dh_modulus, 0) == 0 ||
<a name="line498"></a>                $lib->cmp($dh_gen, 0) == 0) {
<a name="line499"></a>                return new Auth_OpenID_ServerError(
<a name="line500"></a>                  $message, "Failed to parse dh_mod or dh_gen");
<a name="line501"></a>            }
<a name="line502"></a>            $dh = new Auth_OpenID_DiffieHellman($dh_modulus, $dh_gen);
<a name="line503"></a>        } else {
<a name="line504"></a>            $dh = new Auth_OpenID_DiffieHellman();
<a name="line505"></a>        }
<a name="line506"></a>
<a name="line507"></a>        $consumer_pubkey = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line508"></a>                                            'dh_consumer_public');
<a name="line509"></a>        if ($consumer_pubkey === null) {
<a name="line510"></a>            return new Auth_OpenID_ServerError($message,
<a name="line511"></a>                                  'Public key for DH-SHA1 session '.
<a name="line512"></a>                                  'not found in query');
<a name="line513"></a>        }
<a name="line514"></a>
<a name="line515"></a>        $consumer_pubkey =
<a name="line516"></a>            $lib->base64ToLong($consumer_pubkey);
<a name="line517"></a>
<a name="line518"></a>        if ($consumer_pubkey === false) {
<a name="line519"></a>            return new Auth_OpenID_ServerError($message,
<a name="line520"></a>                                       "dh_consumer_public is not base64");
<a name="line521"></a>        }
<a name="line522"></a>
<a name="line523"></a>        return array($dh, $consumer_pubkey);
<a name="line524"></a>    }
<a name="line525"></a>
<a name="line526"></a>    static function fromMessage($message)
<a name="line527"></a>    {
<a name="line528"></a>        $result = Auth_OpenID_DiffieHellmanSHA1ServerSession::getDH($message);
<a name="line529"></a>
<a name="line530"></a>        if (is_a($result, 'Auth_OpenID_ServerError')) {
<a name="line531"></a>            return $result;
<a name="line532"></a>        } else {
<a name="line533"></a>            list($dh, $consumer_pubkey) = $result;
<a name="line534"></a>            return new Auth_OpenID_DiffieHellmanSHA1ServerSession($dh,
<a name="line535"></a>                                                    $consumer_pubkey);
<a name="line536"></a>        }
<a name="line537"></a>    }
<a name="line538"></a>
<a name="line539"></a>    function answer($secret)
<a name="line540"></a>    {
<a name="line541"></a>        $lib = Auth_OpenID_getMathLib();
<a name="line542"></a>        $mac_key = $this->dh->xorSecret($this->consumer_pubkey, $secret,
<a name="line543"></a>                                        $this->hash_func);
<a name="line544"></a>        return array(
<a name="line545"></a>           'dh_server_public' =>
<a name="line546"></a>                $lib->longToBase64($this->dh->public),
<a name="line547"></a>           'enc_mac_key' => base64_encode($mac_key));
<a name="line548"></a>    }
<a name="line549"></a>}
<a name="line550"></a>
<a name="line551"></a>/**
<a name="line552"></a> * A class implementing DH-SHA256 server sessions.
<a name="line553"></a> *
<a name="line554"></a> * @package OpenID
<a name="line555"></a> */
<a name="line556"></a>class Auth_OpenID_DiffieHellmanSHA256ServerSession
<a name="line557"></a>      extends Auth_OpenID_DiffieHellmanSHA1ServerSession {
<a name="line558"></a>
<a name="line559"></a>    var $session_type = 'DH-SHA256';
<a name="line560"></a>    var $hash_func = 'Auth_OpenID_SHA256';
<a name="line561"></a>    var $allowed_assoc_types = array('HMAC-SHA256');
<a name="line562"></a>
<a name="line563"></a>    static function fromMessage($message)
<a name="line564"></a>    {
<a name="line565"></a>        $result = Auth_OpenID_DiffieHellmanSHA1ServerSession::getDH($message);
<a name="line566"></a>
<a name="line567"></a>        if (is_a($result, 'Auth_OpenID_ServerError')) {
<a name="line568"></a>            return $result;
<a name="line569"></a>        } else {
<a name="line570"></a>            list($dh, $consumer_pubkey) = $result;
<a name="line571"></a>            return new Auth_OpenID_DiffieHellmanSHA256ServerSession($dh,
<a name="line572"></a>                                                      $consumer_pubkey);
<a name="line573"></a>        }
<a name="line574"></a>    }
<a name="line575"></a>}
<a name="line576"></a>
<a name="line577"></a>/**
<a name="line578"></a> * A request to associate with the server.
<a name="line579"></a> *
<a name="line580"></a> * @package OpenID
<a name="line581"></a> */
<a name="line582"></a>class Auth_OpenID_AssociateRequest extends Auth_OpenID_Request {
<a name="line583"></a>    var $mode = "associate";
<a name="line584"></a>
<a name="line585"></a>    static function getSessionClasses()
<a name="line586"></a>    {
<a name="line587"></a>        return array(
<a name="line588"></a>          'no-encryption' => 'Auth_OpenID_PlainTextServerSession',
<a name="line589"></a>          'DH-SHA1' => 'Auth_OpenID_DiffieHellmanSHA1ServerSession',
<a name="line590"></a>          'DH-SHA256' => 'Auth_OpenID_DiffieHellmanSHA256ServerSession');
<a name="line591"></a>    }
<a name="line592"></a>
<a name="line593"></a>    function Auth_OpenID_AssociateRequest($session, $assoc_type)
<a name="line594"></a>    {
<a name="line595"></a>        $this->session = $session;
<a name="line596"></a>        $this->namespace = Auth_OpenID_OPENID2_NS;
<a name="line597"></a>        $this->assoc_type = $assoc_type;
<a name="line598"></a>    }
<a name="line599"></a>
<a name="line600"></a>    static function fromMessage($message, $server=null)
<a name="line601"></a>    {
<a name="line602"></a>        if ($message->isOpenID1()) {
<a name="line603"></a>            $session_type = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line604"></a>                                             'session_type');
<a name="line605"></a>
<a name="line606"></a>            if ($session_type == 'no-encryption') {
<a name="line607"></a>                // oidutil.log('Received OpenID 1 request with a no-encryption '
<a name="line608"></a>                //             'assocaition session type. Continuing anyway.')
<a name="line609"></a>            } else if (!$session_type) {
<a name="line610"></a>                $session_type = 'no-encryption';
<a name="line611"></a>            }
<a name="line612"></a>        } else {
<a name="line613"></a>            $session_type = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line614"></a>                                             'session_type');
<a name="line615"></a>            if ($session_type === null) {
<a name="line616"></a>                return new Auth_OpenID_ServerError($message,
<a name="line617"></a>                  "session_type missing from request");
<a name="line618"></a>            }
<a name="line619"></a>        }
<a name="line620"></a>
<a name="line621"></a>        $session_class = Auth_OpenID::arrayGet(
<a name="line622"></a>           Auth_OpenID_AssociateRequest::getSessionClasses(),
<a name="line623"></a>           $session_type);
<a name="line624"></a>
<a name="line625"></a>        if ($session_class === null) {
<a name="line626"></a>            return new Auth_OpenID_ServerError($message,
<a name="line627"></a>                                               "Unknown session type " .
<a name="line628"></a>                                               $session_type);
<a name="line629"></a>        }
<a name="line630"></a>
<a name="line631"></a>        $session = call_user_func(array($session_class, 'fromMessage'),
<a name="line632"></a>                                  $message);
<a name="line633"></a>        if (is_a($session, 'Auth_OpenID_ServerError')) {
<a name="line634"></a>            return $session;
<a name="line635"></a>        }
<a name="line636"></a>
<a name="line637"></a>        $assoc_type = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line638"></a>                                       'assoc_type', 'HMAC-SHA1');
<a name="line639"></a>
<a name="line640"></a>        if (!in_array($assoc_type, $session->allowed_assoc_types)) {
<a name="line641"></a>            $fmt = "Session type %s does not support association type %s";
<a name="line642"></a>            return new Auth_OpenID_ServerError($message,
<a name="line643"></a>              sprintf($fmt, $session_type, $assoc_type));
<a name="line644"></a>        }
<a name="line645"></a>
<a name="line646"></a>        $obj = new Auth_OpenID_AssociateRequest($session, $assoc_type);
<a name="line647"></a>        $obj->message = $message;
<a name="line648"></a>        $obj->namespace = $message->getOpenIDNamespace();
<a name="line649"></a>        return $obj;
<a name="line650"></a>    }
<a name="line651"></a>
<a name="line652"></a>    function answer($assoc)
<a name="line653"></a>    {
<a name="line654"></a>        $response = new Auth_OpenID_ServerResponse($this);
<a name="line655"></a>        $response->fields->updateArgs(Auth_OpenID_OPENID_NS,
<a name="line656"></a>           array(
<a name="line657"></a>                 'expires_in' => sprintf('%d', $assoc->getExpiresIn()),
<a name="line658"></a>                 'assoc_type' => $this->assoc_type,
<a name="line659"></a>                 'assoc_handle' => $assoc->handle));
<a name="line660"></a>
<a name="line661"></a>        $response->fields->updateArgs(Auth_OpenID_OPENID_NS,
<a name="line662"></a>           $this->session->answer($assoc->secret));
<a name="line663"></a>
<a name="line664"></a>        if (! ($this->session->session_type == 'no-encryption' 
<a name="line665"></a>               && $this->message->isOpenID1())) {
<a name="line666"></a>            $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line667"></a>                                      'session_type',
<a name="line668"></a>                                      $this->session->session_type);
<a name="line669"></a>        }
<a name="line670"></a>
<a name="line671"></a>        return $response;
<a name="line672"></a>    }
<a name="line673"></a>
<a name="line674"></a>    function answerUnsupported($text_message,
<a name="line675"></a>                               $preferred_association_type=null,
<a name="line676"></a>                               $preferred_session_type=null)
<a name="line677"></a>    {
<a name="line678"></a>        if ($this->message->isOpenID1()) {
<a name="line679"></a>            return new Auth_OpenID_ServerError($this->message);
<a name="line680"></a>        }
<a name="line681"></a>
<a name="line682"></a>        $response = new Auth_OpenID_ServerResponse($this);
<a name="line683"></a>        $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line684"></a>                                  'error_code', 'unsupported-type');
<a name="line685"></a>        $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line686"></a>                                  'error', $text_message);
<a name="line687"></a>
<a name="line688"></a>        if ($preferred_association_type) {
<a name="line689"></a>            $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line690"></a>                                      'assoc_type',
<a name="line691"></a>                                      $preferred_association_type);
<a name="line692"></a>        }
<a name="line693"></a>
<a name="line694"></a>        if ($preferred_session_type) {
<a name="line695"></a>            $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line696"></a>                                      'session_type',
<a name="line697"></a>                                      $preferred_session_type);
<a name="line698"></a>        }
<a name="line699"></a>        $response->code = AUTH_OPENID_HTTP_ERROR;
<a name="line700"></a>        return $response;
<a name="line701"></a>    }
<a name="line702"></a>}
<a name="line703"></a>
<a name="line704"></a>/**
<a name="line705"></a> * A request to confirm the identity of a user.
<a name="line706"></a> *
<a name="line707"></a> * @package OpenID
<a name="line708"></a> */
<a name="line709"></a>class Auth_OpenID_CheckIDRequest extends Auth_OpenID_Request {
<a name="line710"></a>    /**
<a name="line711"></a>     * Return-to verification callback.  Default is
<a name="line712"></a>     * Auth_OpenID_verifyReturnTo from TrustRoot.php.
<a name="line713"></a>     */
<a name="line714"></a>    var $verifyReturnTo = 'Auth_OpenID_verifyReturnTo';
<a name="line715"></a>
<a name="line716"></a>    /**
<a name="line717"></a>     * The mode of this request.
<a name="line718"></a>     */
<a name="line719"></a>    var $mode = "checkid_setup"; // or "checkid_immediate"
<a name="line720"></a>
<a name="line721"></a>    /**
<a name="line722"></a>     * Whether this request is for immediate mode.
<a name="line723"></a>     */
<a name="line724"></a>    var $immediate = false;
<a name="line725"></a>
<a name="line726"></a>    /**
<a name="line727"></a>     * The trust_root value for this request.
<a name="line728"></a>     */
<a name="line729"></a>    var $trust_root = null;
<a name="line730"></a>
<a name="line731"></a>    /**
<a name="line732"></a>     * The OpenID namespace for this request.
<a name="line733"></a>     * deprecated since version 2.0.2
<a name="line734"></a>     */
<a name="line735"></a>    var $namespace;
<a name="line736"></a>    
<a name="line737"></a>    static function make($message, $identity, $return_to, $trust_root = null,
<a name="line738"></a>                  $immediate = false, $assoc_handle = null, $server = null)
<a name="line739"></a>    {
<a name="line740"></a>        if ($server === null) {
<a name="line741"></a>            return new Auth_OpenID_ServerError($message,
<a name="line742"></a>                                               "server must not be null");
<a name="line743"></a>        }
<a name="line744"></a>
<a name="line745"></a>        if ($return_to &&
<a name="line746"></a>            !Auth_OpenID_TrustRoot::_parse($return_to)) {
<a name="line747"></a>            return new Auth_OpenID_MalformedReturnURL($message, $return_to);
<a name="line748"></a>        }
<a name="line749"></a>
<a name="line750"></a>        $r = new Auth_OpenID_CheckIDRequest($identity, $return_to,
<a name="line751"></a>                                            $trust_root, $immediate,
<a name="line752"></a>                                            $assoc_handle, $server);
<a name="line753"></a>
<a name="line754"></a>        $r->namespace = $message->getOpenIDNamespace();
<a name="line755"></a>        $r->message = $message;
<a name="line756"></a>
<a name="line757"></a>        if (!$r->trustRootValid()) {
<a name="line758"></a>            return new Auth_OpenID_UntrustedReturnURL($message,
<a name="line759"></a>                                                      $return_to,
<a name="line760"></a>                                                      $trust_root);
<a name="line761"></a>        } else {
<a name="line762"></a>            return $r;
<a name="line763"></a>        }
<a name="line764"></a>    }
<a name="line765"></a>
<a name="line766"></a>    function Auth_OpenID_CheckIDRequest($identity, $return_to,
<a name="line767"></a>                                        $trust_root = null, $immediate = false,
<a name="line768"></a>                                        $assoc_handle = null, $server = null,
<a name="line769"></a>                                        $claimed_id = null)
<a name="line770"></a>    {
<a name="line771"></a>        $this->namespace = Auth_OpenID_OPENID2_NS;
<a name="line772"></a>        $this->assoc_handle = $assoc_handle;
<a name="line773"></a>        $this->identity = $identity;
<a name="line774"></a>        if ($claimed_id === null) {
<a name="line775"></a>            $this->claimed_id = $identity;
<a name="line776"></a>        } else {
<a name="line777"></a>            $this->claimed_id = $claimed_id;
<a name="line778"></a>        }
<a name="line779"></a>        $this->return_to = $return_to;
<a name="line780"></a>        $this->trust_root = $trust_root;
<a name="line781"></a>        $this->server = $server;
<a name="line782"></a>
<a name="line783"></a>        if ($immediate) {
<a name="line784"></a>            $this->immediate = true;
<a name="line785"></a>            $this->mode = "checkid_immediate";
<a name="line786"></a>        } else {
<a name="line787"></a>            $this->immediate = false;
<a name="line788"></a>            $this->mode = "checkid_setup";
<a name="line789"></a>        }
<a name="line790"></a>    }
<a name="line791"></a>
<a name="line792"></a>    function equals($other)
<a name="line793"></a>    {
<a name="line794"></a>        return (
<a name="line795"></a>                (is_a($other, 'Auth_OpenID_CheckIDRequest')) &&
<a name="line796"></a>                ($this->namespace == $other->namespace) &&
<a name="line797"></a>                ($this->assoc_handle == $other->assoc_handle) &&
<a name="line798"></a>                ($this->identity == $other->identity) &&
<a name="line799"></a>                ($this->claimed_id == $other->claimed_id) &&
<a name="line800"></a>                ($this->return_to == $other->return_to) &&
<a name="line801"></a>                ($this->trust_root == $other->trust_root));
<a name="line802"></a>    }
<a name="line803"></a>
<a name="line804"></a>    /*
<a name="line805"></a>     * Does the relying party publish the return_to URL for this
<a name="line806"></a>     * response under the realm? It is up to the provider to set a
<a name="line807"></a>     * policy for what kinds of realms should be allowed. This
<a name="line808"></a>     * return_to URL verification reduces vulnerability to data-theft
<a name="line809"></a>     * attacks based on open proxies, corss-site-scripting, or open
<a name="line810"></a>     * redirectors.
<a name="line811"></a>     *
<a name="line812"></a>     * This check should only be performed after making sure that the
<a name="line813"></a>     * return_to URL matches the realm.
<a name="line814"></a>     *
<a name="line815"></a>     * @return true if the realm publishes a document with the
<a name="line816"></a>     * return_to URL listed, false if not or if discovery fails
<a name="line817"></a>     */
<a name="line818"></a>    function returnToVerified()
<a name="line819"></a>    {
<a name="line820"></a>    	$fetcher = Auth_Yadis_Yadis::getHTTPFetcher();
<a name="line821"></a>        return call_user_func_array($this->verifyReturnTo,
<a name="line822"></a>                                    array($this->trust_root, $this->return_to, $fetcher));
<a name="line823"></a>    }
<a name="line824"></a>    
<a name="line825"></a>    static function fromMessage($message, $server)
<a name="line826"></a>    {
<a name="line827"></a>        $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode');
<a name="line828"></a>        $immediate = null;
<a name="line829"></a>
<a name="line830"></a>        if ($mode == "checkid_immediate") {
<a name="line831"></a>            $immediate = true;
<a name="line832"></a>            $mode = "checkid_immediate";
<a name="line833"></a>        } else {
<a name="line834"></a>            $immediate = false;
<a name="line835"></a>            $mode = "checkid_setup";
<a name="line836"></a>        }
<a name="line837"></a>
<a name="line838"></a>        $return_to = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line839"></a>                                      'return_to');
<a name="line840"></a>
<a name="line841"></a>        if (($message->isOpenID1()) &&
<a name="line842"></a>            (!$return_to)) {
<a name="line843"></a>            $fmt = "Missing required field 'return_to' from checkid request";
<a name="line844"></a>            return new Auth_OpenID_ServerError($message, $fmt);
<a name="line845"></a>        }
<a name="line846"></a>
<a name="line847"></a>        $identity = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line848"></a>                                     'identity');
<a name="line849"></a>        $claimed_id = $message->getArg(Auth_OpenID_OPENID_NS, 'claimed_id');
<a name="line850"></a>        if ($message->isOpenID1()) {
<a name="line851"></a>            if ($identity === null) {
<a name="line852"></a>                $s = "OpenID 1 message did not contain openid.identity";
<a name="line853"></a>                return new Auth_OpenID_ServerError($message, $s);
<a name="line854"></a>            }
<a name="line855"></a>        } else {
<a name="line856"></a>            if ($identity && !$claimed_id) {
<a name="line857"></a>                $s = "OpenID 2.0 message contained openid.identity but not " .
<a name="line858"></a>                  "claimed_id";
<a name="line859"></a>                return new Auth_OpenID_ServerError($message, $s);
<a name="line860"></a>            } else if ($claimed_id && !$identity) {
<a name="line861"></a>                $s = "OpenID 2.0 message contained openid.claimed_id " .
<a name="line862"></a>                  "but not identity";
<a name="line863"></a>                return new Auth_OpenID_ServerError($message, $s);
<a name="line864"></a>            }
<a name="line865"></a>        }
<a name="line866"></a>
<a name="line867"></a>        // There's a case for making self.trust_root be a TrustRoot
<a name="line868"></a>        // here.  But if TrustRoot isn't currently part of the
<a name="line869"></a>        // "public" API, I'm not sure it's worth doing.
<a name="line870"></a>        if ($message->isOpenID1()) {
<a name="line871"></a>            $trust_root_param = 'trust_root';
<a name="line872"></a>        } else {
<a name="line873"></a>            $trust_root_param = 'realm';
<a name="line874"></a>        }
<a name="line875"></a>        $trust_root = $message->getArg(Auth_OpenID_OPENID_NS, 
<a name="line876"></a>                                       $trust_root_param);
<a name="line877"></a>        if (! $trust_root) {
<a name="line878"></a>            $trust_root = $return_to;
<a name="line879"></a>        }
<a name="line880"></a>
<a name="line881"></a>        if (! $message->isOpenID1() && 
<a name="line882"></a>            ($return_to === null) &&
<a name="line883"></a>            ($trust_root === null)) {
<a name="line884"></a>            return new Auth_OpenID_ServerError($message,
<a name="line885"></a>              "openid.realm required when openid.return_to absent");
<a name="line886"></a>        }
<a name="line887"></a>
<a name="line888"></a>        $assoc_handle = $message->getArg(Auth_OpenID_OPENID_NS,
<a name="line889"></a>                                         'assoc_handle');
<a name="line890"></a>
<a name="line891"></a>        $obj = Auth_OpenID_CheckIDRequest::make($message,
<a name="line892"></a>                                                $identity,
<a name="line893"></a>                                                $return_to,
<a name="line894"></a>                                                $trust_root,
<a name="line895"></a>                                                $immediate,
<a name="line896"></a>                                                $assoc_handle,
<a name="line897"></a>                                                $server);
<a name="line898"></a>
<a name="line899"></a>        if (is_a($obj, 'Auth_OpenID_ServerError')) {
<a name="line900"></a>            return $obj;
<a name="line901"></a>        }
<a name="line902"></a>
<a name="line903"></a>        $obj->claimed_id = $claimed_id;
<a name="line904"></a>
<a name="line905"></a>        return $obj;
<a name="line906"></a>    }
<a name="line907"></a>
<a name="line908"></a>    function idSelect()
<a name="line909"></a>    {
<a name="line910"></a>        // Is the identifier to be selected by the IDP?
<a name="line911"></a>        // So IDPs don't have to import the constant
<a name="line912"></a>        return $this->identity == Auth_OpenID_IDENTIFIER_SELECT;
<a name="line913"></a>    }
<a name="line914"></a>
<a name="line915"></a>    function trustRootValid()
<a name="line916"></a>    {
<a name="line917"></a>        if (!$this->trust_root) {
<a name="line918"></a>            return true;
<a name="line919"></a>        }
<a name="line920"></a>
<a name="line921"></a>        $tr = Auth_OpenID_TrustRoot::_parse($this->trust_root);
<a name="line922"></a>        if ($tr === false) {
<a name="line923"></a>            return new Auth_OpenID_MalformedTrustRoot($this->message,
<a name="line924"></a>                                                      $this->trust_root);
<a name="line925"></a>        }
<a name="line926"></a>
<a name="line927"></a>        if ($this->return_to !== null) {
<a name="line928"></a>            return Auth_OpenID_TrustRoot::match($this->trust_root,
<a name="line929"></a>                                                $this->return_to);
<a name="line930"></a>        } else {
<a name="line931"></a>            return true;
<a name="line932"></a>        }
<a name="line933"></a>    }
<a name="line934"></a>
<a name="line935"></a>    /**
<a name="line936"></a>     * Respond to this request.  Return either an
<a name="line937"></a>     * {@link Auth_OpenID_ServerResponse} or
<a name="line938"></a>     * {@link Auth_OpenID_ServerError}.
<a name="line939"></a>     *
<a name="line940"></a>     * @param bool $allow Allow this user to claim this identity, and
<a name="line941"></a>     * allow the consumer to have this information?
<a name="line942"></a>     *
<a name="line943"></a>     * @param string $server_url DEPRECATED.  Passing $op_endpoint to
<a name="line944"></a>     * the {@link Auth_OpenID_Server} constructor makes this optional.
<a name="line945"></a>     *
<a name="line946"></a>     * When an OpenID 1.x immediate mode request does not succeed, it
<a name="line947"></a>     * gets back a URL where the request may be carried out in a
<a name="line948"></a>     * not-so-immediate fashion.  Pass my URL in here (the fully
<a name="line949"></a>     * qualified address of this server's endpoint, i.e.
<a name="line950"></a>     * http://example.com/server), and I will use it as a base for the
<a name="line951"></a>     * URL for a new request.
<a name="line952"></a>     *
<a name="line953"></a>     * Optional for requests where {@link $immediate} is false or
<a name="line954"></a>     * $allow is true.
<a name="line955"></a>     *
<a name="line956"></a>     * @param string $identity The OP-local identifier to answer with.
<a name="line957"></a>     * Only for use when the relying party requested identifier
<a name="line958"></a>     * selection.
<a name="line959"></a>     *
<a name="line960"></a>     * @param string $claimed_id The claimed identifier to answer
<a name="line961"></a>     * with, for use with identifier selection in the case where the
<a name="line962"></a>     * claimed identifier and the OP-local identifier differ,
<a name="line963"></a>     * i.e. when the claimed_id uses delegation.
<a name="line964"></a>     *
<a name="line965"></a>     * If $identity is provided but this is not, $claimed_id will
<a name="line966"></a>     * default to the value of $identity.  When answering requests
<a name="line967"></a>     * that did not ask for identifier selection, the response
<a name="line968"></a>     * $claimed_id will default to that of the request.
<a name="line969"></a>     *
<a name="line970"></a>     * This parameter is new in OpenID 2.0.
<a name="line971"></a>     *
<a name="line972"></a>     * @return mixed
<a name="line973"></a>     */
<a name="line974"></a>    function answer($allow, $server_url = null, $identity = null,
<a name="line975"></a>                    $claimed_id = null)
<a name="line976"></a>    {
<a name="line977"></a>        if (!$this->return_to) {
<a name="line978"></a>            return new Auth_OpenID_NoReturnToError();
<a name="line979"></a>        }
<a name="line980"></a>
<a name="line981"></a>        if (!$server_url) {
<a name="line982"></a>            if ((!$this->message->isOpenID1()) &&
<a name="line983"></a>                (!$this->server->op_endpoint)) {
<a name="line984"></a>                return new Auth_OpenID_ServerError(null,
<a name="line985"></a>                  "server should be constructed with op_endpoint to " .
<a name="line986"></a>                  "respond to OpenID 2.0 messages.");
<a name="line987"></a>            }
<a name="line988"></a>
<a name="line989"></a>            $server_url = $this->server->op_endpoint;
<a name="line990"></a>        }
<a name="line991"></a>
<a name="line992"></a>        if ($allow) {
<a name="line993"></a>            $mode = 'id_res';
<a name="line994"></a>        } else if ($this->message->isOpenID1()) {
<a name="line995"></a>            if ($this->immediate) {
<a name="line996"></a>                $mode = 'id_res';
<a name="line997"></a>            } else {
<a name="line998"></a>                $mode = 'cancel';
<a name="line999"></a>            }
<a name="line1000"></a>        } else {
<a name="line1001"></a>            if ($this->immediate) {
<a name="line1002"></a>                $mode = 'setup_needed';
<a name="line1003"></a>            } else {
<a name="line1004"></a>                $mode = 'cancel';
<a name="line1005"></a>            }
<a name="line1006"></a>        }
<a name="line1007"></a>
<a name="line1008"></a>        if (!$this->trustRootValid()) {
<a name="line1009"></a>            return new Auth_OpenID_UntrustedReturnURL(null,
<a name="line1010"></a>                                                      $this->return_to,
<a name="line1011"></a>                                                      $this->trust_root);
<a name="line1012"></a>        }
<a name="line1013"></a>
<a name="line1014"></a>        $response = new Auth_OpenID_ServerResponse($this);
<a name="line1015"></a>
<a name="line1016"></a>        if ($claimed_id &&
<a name="line1017"></a>            ($this->message->isOpenID1())) {
<a name="line1018"></a>            return new Auth_OpenID_ServerError(null,
<a name="line1019"></a>              "claimed_id is new in OpenID 2.0 and not " .
<a name="line1020"></a>              "available for ".$this->namespace);
<a name="line1021"></a>        }
<a name="line1022"></a>
<a name="line1023"></a>        if ($identity && !$claimed_id) {
<a name="line1024"></a>            $claimed_id = $identity;
<a name="line1025"></a>        }
<a name="line1026"></a>
<a name="line1027"></a>        if ($allow) {
<a name="line1028"></a>
<a name="line1029"></a>            if ($this->identity == Auth_OpenID_IDENTIFIER_SELECT) {
<a name="line1030"></a>                if (!$identity) {
<a name="line1031"></a>                    return new Auth_OpenID_ServerError(null,
<a name="line1032"></a>                      "This request uses IdP-driven identifier selection.  " .
<a name="line1033"></a>                      "You must supply an identifier in the response.");
<a name="line1034"></a>                }
<a name="line1035"></a>
<a name="line1036"></a>                $response_identity = $identity;
<a name="line1037"></a>                $response_claimed_id = $claimed_id;
<a name="line1038"></a>
<a name="line1039"></a>            } else if ($this->identity) {
<a name="line1040"></a>                if ($identity &&
<a name="line1041"></a>                    ($this->identity != $identity)) {
<a name="line1042"></a>                    $fmt = "Request was for %s, cannot reply with identity %s";
<a name="line1043"></a>                    return new Auth_OpenID_ServerError(null,
<a name="line1044"></a>                      sprintf($fmt, $this->identity, $identity));
<a name="line1045"></a>                }
<a name="line1046"></a>
<a name="line1047"></a>                $response_identity = $this->identity;
<a name="line1048"></a>                $response_claimed_id = $this->claimed_id;
<a name="line1049"></a>            } else {
<a name="line1050"></a>                if ($identity) {
<a name="line1051"></a>                    return new Auth_OpenID_ServerError(null,
<a name="line1052"></a>                      "This request specified no identity and " .
<a name="line1053"></a>                      "you supplied ".$identity);
<a name="line1054"></a>                }
<a name="line1055"></a>
<a name="line1056"></a>                $response_identity = null;
<a name="line1057"></a>            }
<a name="line1058"></a>
<a name="line1059"></a>            if (($this->message->isOpenID1()) &&
<a name="line1060"></a>                ($response_identity === null)) {
<a name="line1061"></a>                return new Auth_OpenID_ServerError(null,
<a name="line1062"></a>                  "Request was an OpenID 1 request, so response must " .
<a name="line1063"></a>                  "include an identifier.");
<a name="line1064"></a>            }
<a name="line1065"></a>
<a name="line1066"></a>            $response->fields->updateArgs(Auth_OpenID_OPENID_NS,
<a name="line1067"></a>                   array('mode' => $mode,
<a name="line1068"></a>                         'return_to' => $this->return_to,
<a name="line1069"></a>                         'response_nonce' => Auth_OpenID_mkNonce()));
<a name="line1070"></a>
<a name="line1071"></a>            if (!$this->message->isOpenID1()) {
<a name="line1072"></a>                $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line1073"></a>                                          'op_endpoint', $server_url);
<a name="line1074"></a>            }
<a name="line1075"></a>
<a name="line1076"></a>            if ($response_identity !== null) {
<a name="line1077"></a>                $response->fields->setArg(
<a name="line1078"></a>                                          Auth_OpenID_OPENID_NS,
<a name="line1079"></a>                                          'identity',
<a name="line1080"></a>                                          $response_identity);
<a name="line1081"></a>                if ($this->message->isOpenID2()) {
<a name="line1082"></a>                    $response->fields->setArg(
<a name="line1083"></a>                                              Auth_OpenID_OPENID_NS,
<a name="line1084"></a>                                              'claimed_id',
<a name="line1085"></a>                                              $response_claimed_id);
<a name="line1086"></a>                }
<a name="line1087"></a>            }
<a name="line1088"></a>
<a name="line1089"></a>        } else {
<a name="line1090"></a>            $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line1091"></a>                                      'mode', $mode);
<a name="line1092"></a>
<a name="line1093"></a>            if ($this->immediate) {
<a name="line1094"></a>                if (($this->message->isOpenID1()) &&
<a name="line1095"></a>                    (!$server_url)) {
<a name="line1096"></a>                    return new Auth_OpenID_ServerError(null,
<a name="line1097"></a>                                 'setup_url is required for $allow=false \
<a name="line1098"></a>                                  in OpenID 1.x immediate mode.');
<a name="line1099"></a>                }
<a name="line1100"></a>
<a name="line1101"></a>                $setup_request = new Auth_OpenID_CheckIDRequest(
<a name="line1102"></a>                                                $this->identity,
<a name="line1103"></a>                                                $this->return_to,
<a name="line1104"></a>                                                $this->trust_root,
<a name="line1105"></a>                                                false,
<a name="line1106"></a>                                                $this->assoc_handle,
<a name="line1107"></a>                                                $this->server,
<a name="line1108"></a>                                                $this->claimed_id);
<a name="line1109"></a>                $setup_request->message = $this->message;
<a name="line1110"></a>
<a name="line1111"></a>                $setup_url = $setup_request->encodeToURL($server_url);
<a name="line1112"></a>
<a name="line1113"></a>                if ($setup_url === null) {
<a name="line1114"></a>                    return new Auth_OpenID_NoReturnToError();
<a name="line1115"></a>                }
<a name="line1116"></a>
<a name="line1117"></a>                $response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line1118"></a>                                          'user_setup_url',
<a name="line1119"></a>                                          $setup_url);
<a name="line1120"></a>            }
<a name="line1121"></a>        }
<a name="line1122"></a>
<a name="line1123"></a>        return $response;
<a name="line1124"></a>    }
<a name="line1125"></a>
<a name="line1126"></a>    function encodeToURL($server_url)
<a name="line1127"></a>    {
<a name="line1128"></a>        if (!$this->return_to) {
<a name="line1129"></a>            return new Auth_OpenID_NoReturnToError();
<a name="line1130"></a>        }
<a name="line1131"></a>
<a name="line1132"></a>        // Imported from the alternate reality where these classes are
<a name="line1133"></a>        // used in both the client and server code, so Requests are
<a name="line1134"></a>        // Encodable too.  That's right, code imported from alternate
<a name="line1135"></a>        // realities all for the love of you, id_res/user_setup_url.
<a name="line1136"></a>
<a name="line1137"></a>        $q = array('mode' => $this->mode,
<a name="line1138"></a>                   'identity' => $this->identity,
<a name="line1139"></a>                   'claimed_id' => $this->claimed_id,
<a name="line1140"></a>                   'return_to' => $this->return_to);
<a name="line1141"></a>
<a name="line1142"></a>        if ($this->trust_root) {
<a name="line1143"></a>            if ($this->message->isOpenID1()) {
<a name="line1144"></a>                $q['trust_root'] = $this->trust_root;
<a name="line1145"></a>            } else {
<a name="line1146"></a>                $q['realm'] = $this->trust_root;
<a name="line1147"></a>            }
<a name="line1148"></a>        }
<a name="line1149"></a>
<a name="line1150"></a>        if ($this->assoc_handle) {
<a name="line1151"></a>            $q['assoc_handle'] = $this->assoc_handle;
<a name="line1152"></a>        }
<a name="line1153"></a>
<a name="line1154"></a>        $response = new Auth_OpenID_Message(
<a name="line1155"></a>            $this->message->getOpenIDNamespace());
<a name="line1156"></a>        $response->updateArgs(Auth_OpenID_OPENID_NS, $q);
<a name="line1157"></a>        return $response->toURL($server_url);
<a name="line1158"></a>    }
<a name="line1159"></a>
<a name="line1160"></a>    function getCancelURL()
<a name="line1161"></a>    {
<a name="line1162"></a>        if (!$this->return_to) {
<a name="line1163"></a>            return new Auth_OpenID_NoReturnToError();
<a name="line1164"></a>        }
<a name="line1165"></a>
<a name="line1166"></a>        if ($this->immediate) {
<a name="line1167"></a>            return new Auth_OpenID_ServerError(null,
<a name="line1168"></a>                                               "Cancel is not an appropriate \
<a name="line1169"></a>                                               response to immediate mode \
<a name="line1170"></a>                                               requests.");
<a name="line1171"></a>        }
<a name="line1172"></a>
<a name="line1173"></a>        $response = new Auth_OpenID_Message(
<a name="line1174"></a>            $this->message->getOpenIDNamespace());
<a name="line1175"></a>        $response->setArg(Auth_OpenID_OPENID_NS, 'mode', 'cancel');
<a name="line1176"></a>        return $response->toURL($this->return_to);
<a name="line1177"></a>    }
<a name="line1178"></a>}
<a name="line1179"></a>
<a name="line1180"></a>/**
<a name="line1181"></a> * This class encapsulates the response to an OpenID server request.
<a name="line1182"></a> *
<a name="line1183"></a> * @package OpenID
<a name="line1184"></a> */
<a name="line1185"></a>class Auth_OpenID_ServerResponse {
<a name="line1186"></a>
<a name="line1187"></a>    function Auth_OpenID_ServerResponse($request)
<a name="line1188"></a>    {
<a name="line1189"></a>        $this->request = $request;
<a name="line1190"></a>        $this->fields = new Auth_OpenID_Message($this->request->namespace);
<a name="line1191"></a>    }
<a name="line1192"></a>
<a name="line1193"></a>    function whichEncoding()
<a name="line1194"></a>    {
<a name="line1195"></a>      global $_Auth_OpenID_Request_Modes;
<a name="line1196"></a>
<a name="line1197"></a>        if (in_array($this->request->mode, $_Auth_OpenID_Request_Modes)) {
<a name="line1198"></a>            if ($this->fields->isOpenID2() &&
<a name="line1199"></a>                (strlen($this->encodeToURL()) >
<a name="line1200"></a>                   Auth_OpenID_OPENID1_URL_LIMIT)) {
<a name="line1201"></a>                return Auth_OpenID_ENCODE_HTML_FORM;
<a name="line1202"></a>            } else {
<a name="line1203"></a>                return Auth_OpenID_ENCODE_URL;
<a name="line1204"></a>            }
<a name="line1205"></a>        } else {
<a name="line1206"></a>            return Auth_OpenID_ENCODE_KVFORM;
<a name="line1207"></a>        }
<a name="line1208"></a>    }
<a name="line1209"></a>
<a name="line1210"></a>    /*
<a name="line1211"></a>     * Returns the form markup for this response.
<a name="line1212"></a>     *
<a name="line1213"></a>     * @return str
<a name="line1214"></a>     */
<a name="line1215"></a>    function toFormMarkup($form_tag_attrs=null)
<a name="line1216"></a>    {
<a name="line1217"></a>        return $this->fields->toFormMarkup($this->request->return_to,
<a name="line1218"></a>                                           $form_tag_attrs);
<a name="line1219"></a>    }
<a name="line1220"></a>
<a name="line1221"></a>    /*
<a name="line1222"></a>     * Returns an HTML document containing the form markup for this
<a name="line1223"></a>     * response that autosubmits with javascript.
<a name="line1224"></a>     */
<a name="line1225"></a>    function toHTML()
<a name="line1226"></a>    {
<a name="line1227"></a>        return Auth_OpenID::autoSubmitHTML($this->toFormMarkup());
<a name="line1228"></a>    }
<a name="line1229"></a>
<a name="line1230"></a>    /*
<a name="line1231"></a>     * Returns True if this response's encoding is ENCODE_HTML_FORM.
<a name="line1232"></a>     * Convenience method for server authors.
<a name="line1233"></a>     *
<a name="line1234"></a>     * @return bool
<a name="line1235"></a>     */
<a name="line1236"></a>    function renderAsForm()
<a name="line1237"></a>    {
<a name="line1238"></a>        return $this->whichEncoding() == Auth_OpenID_ENCODE_HTML_FORM;
<a name="line1239"></a>    }
<a name="line1240"></a>
<a name="line1241"></a>
<a name="line1242"></a>    function encodeToURL()
<a name="line1243"></a>    {
<a name="line1244"></a>        return $this->fields->toURL($this->request->return_to);
<a name="line1245"></a>    }
<a name="line1246"></a>
<a name="line1247"></a>    function addExtension($extension_response)
<a name="line1248"></a>    {
<a name="line1249"></a>        $extension_response->toMessage($this->fields);
<a name="line1250"></a>    }
<a name="line1251"></a>
<a name="line1252"></a>    function needsSigning()
<a name="line1253"></a>    {
<a name="line1254"></a>        return $this->fields->getArg(Auth_OpenID_OPENID_NS,
<a name="line1255"></a>                                     'mode') == 'id_res';
<a name="line1256"></a>    }
<a name="line1257"></a>
<a name="line1258"></a>    function encodeToKVForm()
<a name="line1259"></a>    {
<a name="line1260"></a>        return $this->fields->toKVForm();
<a name="line1261"></a>    }
<a name="line1262"></a>}
<a name="line1263"></a>
<a name="line1264"></a>/**
<a name="line1265"></a> * A web-capable response object which you can use to generate a
<a name="line1266"></a> * user-agent response.
<a name="line1267"></a> *
<a name="line1268"></a> * @package OpenID
<a name="line1269"></a> */
<a name="line1270"></a>class Auth_OpenID_WebResponse {
<a name="line1271"></a>    var $code = AUTH_OPENID_HTTP_OK;
<a name="line1272"></a>    var $body = "";
<a name="line1273"></a>
<a name="line1274"></a>    function Auth_OpenID_WebResponse($code = null, $headers = null,
<a name="line1275"></a>                                     $body = null)
<a name="line1276"></a>    {
<a name="line1277"></a>        if ($code) {
<a name="line1278"></a>            $this->code = $code;
<a name="line1279"></a>        }
<a name="line1280"></a>
<a name="line1281"></a>        if ($headers !== null) {
<a name="line1282"></a>            $this->headers = $headers;
<a name="line1283"></a>        } else {
<a name="line1284"></a>            $this->headers = array();
<a name="line1285"></a>        }
<a name="line1286"></a>
<a name="line1287"></a>        if ($body !== null) {
<a name="line1288"></a>            $this->body = $body;
<a name="line1289"></a>        }
<a name="line1290"></a>    }
<a name="line1291"></a>}
<a name="line1292"></a>
<a name="line1293"></a>/**
<a name="line1294"></a> * Responsible for the signature of query data and the verification of
<a name="line1295"></a> * OpenID signature values.
<a name="line1296"></a> *
<a name="line1297"></a> * @package OpenID
<a name="line1298"></a> */
<a name="line1299"></a>class Auth_OpenID_Signatory {
<a name="line1300"></a>
<a name="line1301"></a>    // = 14 * 24 * 60 * 60; # 14 days, in seconds
<a name="line1302"></a>    var $SECRET_LIFETIME = 1209600;
<a name="line1303"></a>
<a name="line1304"></a>    // keys have a bogus server URL in them because the filestore
<a name="line1305"></a>    // really does expect that key to be a URL.  This seems a little
<a name="line1306"></a>    // silly for the server store, since I expect there to be only one
<a name="line1307"></a>    // server URL.
<a name="line1308"></a>    var $normal_key = 'http://localhost/|normal';
<a name="line1309"></a>    var $dumb_key = 'http://localhost/|dumb';
<a name="line1310"></a>
<a name="line1311"></a>    /**
<a name="line1312"></a>     * Create a new signatory using a given store.
<a name="line1313"></a>     */
<a name="line1314"></a>    function Auth_OpenID_Signatory($store)
<a name="line1315"></a>    {
<a name="line1316"></a>        // assert store is not None
<a name="line1317"></a>        $this->store = $store;
<a name="line1318"></a>    }
<a name="line1319"></a>
<a name="line1320"></a>    /**
<a name="line1321"></a>     * Verify, using a given association handle, a signature with
<a name="line1322"></a>     * signed key-value pairs from an HTTP request.
<a name="line1323"></a>     */
<a name="line1324"></a>    function verify($assoc_handle, $message)
<a name="line1325"></a>    {
<a name="line1326"></a>        $assoc = $this->getAssociation($assoc_handle, true);
<a name="line1327"></a>        if (!$assoc) {
<a name="line1328"></a>            // oidutil.log("failed to get assoc with handle %r to verify sig %r"
<a name="line1329"></a>            //             % (assoc_handle, sig))
<a name="line1330"></a>            return false;
<a name="line1331"></a>        }
<a name="line1332"></a>
<a name="line1333"></a>        return $assoc->checkMessageSignature($message);
<a name="line1334"></a>    }
<a name="line1335"></a>
<a name="line1336"></a>    /**
<a name="line1337"></a>     * Given a response, sign the fields in the response's 'signed'
<a name="line1338"></a>     * list, and insert the signature into the response.
<a name="line1339"></a>     */
<a name="line1340"></a>    function sign($response)
<a name="line1341"></a>    {
<a name="line1342"></a>        $signed_response = $response;
<a name="line1343"></a>        $assoc_handle = $response->request->assoc_handle;
<a name="line1344"></a>
<a name="line1345"></a>        if ($assoc_handle) {
<a name="line1346"></a>            // normal mode
<a name="line1347"></a>            $assoc = $this->getAssociation($assoc_handle, false, false);
<a name="line1348"></a>            if (!$assoc || ($assoc->getExpiresIn() <= 0)) {
<a name="line1349"></a>                // fall back to dumb mode
<a name="line1350"></a>                $signed_response->fields->setArg(Auth_OpenID_OPENID_NS,
<a name="line1351"></a>                             'invalidate_handle', $assoc_handle);
<a name="line1352"></a>                $assoc_type = ($assoc ? $assoc->assoc_type : 'HMAC-SHA1');
<a name="line1353"></a>
<a name="line1354"></a>                if ($assoc && ($assoc->getExpiresIn() <= 0)) {
<a name="line1355"></a>                    $this->invalidate($assoc_handle, false);
<a name="line1356"></a>                }
<a name="line1357"></a>
<a name="line1358"></a>                $assoc = $this->createAssociation(true, $assoc_type);
<a name="line1359"></a>            }
<a name="line1360"></a>        } else {
<a name="line1361"></a>            // dumb mode.
<a name="line1362"></a>            $assoc = $this->createAssociation(true);
<a name="line1363"></a>        }
<a name="line1364"></a>
<a name="line1365"></a>        $signed_response->fields = $assoc->signMessage(
<a name="line1366"></a>                                      $signed_response->fields);
<a name="line1367"></a>        return $signed_response;
<a name="line1368"></a>    }
<a name="line1369"></a>
<a name="line1370"></a>    /**
<a name="line1371"></a>     * Make a new association.
<a name="line1372"></a>     */
<a name="line1373"></a>    function createAssociation($dumb = true, $assoc_type = 'HMAC-SHA1')
<a name="line1374"></a>    {
<a name="line1375"></a>        $secret = Auth_OpenID_CryptUtil::getBytes(
<a name="line1376"></a>                    Auth_OpenID_getSecretSize($assoc_type));
<a name="line1377"></a>
<a name="line1378"></a>        $uniq = base64_encode(Auth_OpenID_CryptUtil::getBytes(4));
<a name="line1379"></a>        $handle = sprintf('{%s}{%x}{%s}', $assoc_type, intval(time()), $uniq);
<a name="line1380"></a>
<a name="line1381"></a>        $assoc = Auth_OpenID_Association::fromExpiresIn(
<a name="line1382"></a>                      $this->SECRET_LIFETIME, $handle, $secret, $assoc_type);
<a name="line1383"></a>
<a name="line1384"></a>        if ($dumb) {
<a name="line1385"></a>            $key = $this->dumb_key;
<a name="line1386"></a>        } else {
<a name="line1387"></a>            $key = $this->normal_key;
<a name="line1388"></a>        }
<a name="line1389"></a>
<a name="line1390"></a>        $this->store->storeAssociation($key, $assoc);
<a name="line1391"></a>        return $assoc;
<a name="line1392"></a>    }
<a name="line1393"></a>
<a name="line1394"></a>    /**
<a name="line1395"></a>     * Given an association handle, get the association from the
<a name="line1396"></a>     * store, or return a ServerError or null if something goes wrong.
<a name="line1397"></a>     */
<a name="line1398"></a>    function getAssociation($assoc_handle, $dumb, $check_expiration=true)
<a name="line1399"></a>    {
<a name="line1400"></a>        if ($assoc_handle === null) {
<a name="line1401"></a>            return new Auth_OpenID_ServerError(null,
<a name="line1402"></a>                                     "assoc_handle must not be null");
<a name="line1403"></a>        }
<a name="line1404"></a>
<a name="line1405"></a>        if ($dumb) {
<a name="line1406"></a>            $key = $this->dumb_key;
<a name="line1407"></a>        } else {
<a name="line1408"></a>            $key = $this->normal_key;
<a name="line1409"></a>        }
<a name="line1410"></a>
<a name="line1411"></a>        $assoc = $this->store->getAssociation($key, $assoc_handle);
<a name="line1412"></a>
<a name="line1413"></a>        if (($assoc !== null) && ($assoc->getExpiresIn() <= 0)) {
<a name="line1414"></a>            if ($check_expiration) {
<a name="line1415"></a>                $this->store->removeAssociation($key, $assoc_handle);
<a name="line1416"></a>                $assoc = null;
<a name="line1417"></a>            }
<a name="line1418"></a>        }
<a name="line1419"></a>
<a name="line1420"></a>        return $assoc;
<a name="line1421"></a>    }
<a name="line1422"></a>
<a name="line1423"></a>    /**
<a name="line1424"></a>     * Invalidate a given association handle.
<a name="line1425"></a>     */
<a name="line1426"></a>    function invalidate($assoc_handle, $dumb)
<a name="line1427"></a>    {
<a name="line1428"></a>        if ($dumb) {
<a name="line1429"></a>            $key = $this->dumb_key;
<a name="line1430"></a>        } else {
<a name="line1431"></a>            $key = $this->normal_key;
<a name="line1432"></a>        }
<a name="line1433"></a>        $this->store->removeAssociation($key, $assoc_handle);
<a name="line1434"></a>    }
<a name="line1435"></a>}
<a name="line1436"></a>
<a name="line1437"></a>/**
<a name="line1438"></a> * Encode an {@link Auth_OpenID_ServerResponse} to an
<a name="line1439"></a> * {@link Auth_OpenID_WebResponse}.
<a name="line1440"></a> *
<a name="line1441"></a> * @package OpenID
<a name="line1442"></a> */
<a name="line1443"></a>class Auth_OpenID_Encoder {
<a name="line1444"></a>
<a name="line1445"></a>    var $responseFactory = 'Auth_OpenID_WebResponse';
<a name="line1446"></a>
<a name="line1447"></a>    /**
<a name="line1448"></a>     * Encode an {@link Auth_OpenID_ServerResponse} and return an
<a name="line1449"></a>     * {@link Auth_OpenID_WebResponse}.
<a name="line1450"></a>     */
<a name="line1451"></a>    function encode($response)
<a name="line1452"></a>    {
<a name="line1453"></a>        $cls = $this->responseFactory;
<a name="line1454"></a>
<a name="line1455"></a>        $encode_as = $response->whichEncoding();
<a name="line1456"></a>        if ($encode_as == Auth_OpenID_ENCODE_KVFORM) {
<a name="line1457"></a>            $wr = new $cls(null, null, $response->encodeToKVForm());
<a name="line1458"></a>            if (is_a($response, 'Auth_OpenID_ServerError')) {
<a name="line1459"></a>                $wr->code = AUTH_OPENID_HTTP_ERROR;
<a name="line1460"></a>            }
<a name="line1461"></a>        } else if ($encode_as == Auth_OpenID_ENCODE_URL) {
<a name="line1462"></a>            $location = $response->encodeToURL();
<a name="line1463"></a>            $wr = new $cls(AUTH_OPENID_HTTP_REDIRECT,
<a name="line1464"></a>                           array('location' => $location));
<a name="line1465"></a>        } else if ($encode_as == Auth_OpenID_ENCODE_HTML_FORM) {
<a name="line1466"></a>          $wr = new $cls(AUTH_OPENID_HTTP_OK, array(),
<a name="line1467"></a>                         $response->toHTML());
<a name="line1468"></a>        } else {
<a name="line1469"></a>            return new Auth_OpenID_EncodingError($response);
<a name="line1470"></a>        }
<a name="line1471"></a>        /* Allow the response to carry a custom error code (ex: for Association errors) */
<a name="line1472"></a>        if(isset($response->code)) {
<a name="line1473"></a>            $wr->code = $response->code;
<a name="line1474"></a>        }
<a name="line1475"></a>        return $wr;
<a name="line1476"></a>    }
<a name="line1477"></a>}
<a name="line1478"></a>
<a name="line1479"></a>/**
<a name="line1480"></a> * An encoder which also takes care of signing fields when required.
<a name="line1481"></a> *
<a name="line1482"></a> * @package OpenID
<a name="line1483"></a> */
<a name="line1484"></a>class Auth_OpenID_SigningEncoder extends Auth_OpenID_Encoder {
<a name="line1485"></a>
<a name="line1486"></a>    function Auth_OpenID_SigningEncoder($signatory)
<a name="line1487"></a>    {
<a name="line1488"></a>        $this->signatory = $signatory;
<a name="line1489"></a>    }
<a name="line1490"></a>
<a name="line1491"></a>    /**
<a name="line1492"></a>     * Sign an {@link Auth_OpenID_ServerResponse} and return an
<a name="line1493"></a>     * {@link Auth_OpenID_WebResponse}.
<a name="line1494"></a>     */
<a name="line1495"></a>    function encode($response)
<a name="line1496"></a>    {
<a name="line1497"></a>        // the isinstance is a bit of a kludge... it means there isn't
<a name="line1498"></a>        // really an adapter to make the interfaces quite match.
<a name="line1499"></a>        if (!is_a($response, 'Auth_OpenID_ServerError') &&
<a name="line1500"></a>            $response->needsSigning()) {
<a name="line1501"></a>
<a name="line1502"></a>            if (!$this->signatory) {
<a name="line1503"></a>                return new Auth_OpenID_ServerError(null,
<a name="line1504"></a>                                       "Must have a store to sign request");
<a name="line1505"></a>            }
<a name="line1506"></a>
<a name="line1507"></a>            if ($response->fields->hasKey(Auth_OpenID_OPENID_NS, 'sig')) {
<a name="line1508"></a>                return new Auth_OpenID_AlreadySigned($response);
<a name="line1509"></a>            }
<a name="line1510"></a>            $response = $this->signatory->sign($response);
<a name="line1511"></a>        }
<a name="line1512"></a>
<a name="line1513"></a>        return parent::encode($response);
<a name="line1514"></a>    }
<a name="line1515"></a>}
<a name="line1516"></a>
<a name="line1517"></a>/**
<a name="line1518"></a> * Decode an incoming query into an Auth_OpenID_Request.
<a name="line1519"></a> *
<a name="line1520"></a> * @package OpenID
<a name="line1521"></a> */
<a name="line1522"></a>class Auth_OpenID_Decoder {
<a name="line1523"></a>
<a name="line1524"></a>    function Auth_OpenID_Decoder($server)
<a name="line1525"></a>    {
<a name="line1526"></a>        $this->server = $server;
<a name="line1527"></a>
<a name="line1528"></a>        $this->handlers = array(
<a name="line1529"></a>            'checkid_setup' => 'Auth_OpenID_CheckIDRequest',
<a name="line1530"></a>            'checkid_immediate' => 'Auth_OpenID_CheckIDRequest',
<a name="line1531"></a>            'check_authentication' => 'Auth_OpenID_CheckAuthRequest',
<a name="line1532"></a>            'associate' => 'Auth_OpenID_AssociateRequest'
<a name="line1533"></a>            );
<a name="line1534"></a>    }
<a name="line1535"></a>
<a name="line1536"></a>    /**
<a name="line1537"></a>     * Given an HTTP query in an array (key-value pairs), decode it
<a name="line1538"></a>     * into an Auth_OpenID_Request object.
<a name="line1539"></a>     */
<a name="line1540"></a>    function decode($query)
<a name="line1541"></a>    {
<a name="line1542"></a>        if (!$query) {
<a name="line1543"></a>            return null;
<a name="line1544"></a>        }
<a name="line1545"></a>
<a name="line1546"></a>        $message = Auth_OpenID_Message::fromPostArgs($query);
<a name="line1547"></a>
<a name="line1548"></a>        if ($message === null) {
<a name="line1549"></a>            /*
<a name="line1550"></a>             * It's useful to have a Message attached to a
<a name="line1551"></a>             * ProtocolError, so we override the bad ns value to build
<a name="line1552"></a>             * a Message out of it.  Kinda kludgy, since it's made of
<a name="line1553"></a>             * lies, but the parts that aren't lies are more useful
<a name="line1554"></a>             * than a 'None'.
<a name="line1555"></a>             */
<a name="line1556"></a>            $old_ns = $query['openid.ns'];
<a name="line1557"></a>
<a name="line1558"></a>            $query['openid.ns'] = Auth_OpenID_OPENID2_NS;
<a name="line1559"></a>            $message = Auth_OpenID_Message::fromPostArgs($query);
<a name="line1560"></a>            return new Auth_OpenID_ServerError(
<a name="line1561"></a>                  $message,
<a name="line1562"></a>                  sprintf("Invalid OpenID namespace URI: %s", $old_ns));
<a name="line1563"></a>        }
<a name="line1564"></a>
<a name="line1565"></a>        $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode');
<a name="line1566"></a>        if (!$mode) {
<a name="line1567"></a>            return new Auth_OpenID_ServerError($message,
<a name="line1568"></a>                                               "No mode value in message");
<a name="line1569"></a>        }
<a name="line1570"></a>
<a name="line1571"></a>        if (Auth_OpenID::isFailure($mode)) {
<a name="line1572"></a>            return new Auth_OpenID_ServerError($message,
<a name="line1573"></a>                                               $mode->message);
<a name="line1574"></a>        }
<a name="line1575"></a>
<a name="line1576"></a>        $handlerCls = Auth_OpenID::arrayGet($this->handlers, $mode,
<a name="line1577"></a>                                            $this->defaultDecoder($message));
<a name="line1578"></a>
<a name="line1579"></a>        if (!is_a($handlerCls, 'Auth_OpenID_ServerError')) {
<a name="line1580"></a>            return call_user_func_array(array($handlerCls, 'fromMessage'),
<a name="line1581"></a>                                        array($message, $this->server));
<a name="line1582"></a>        } else {
<a name="line1583"></a>            return $handlerCls;
<a name="line1584"></a>        }
<a name="line1585"></a>    }
<a name="line1586"></a>
<a name="line1587"></a>    function defaultDecoder($message)
<a name="line1588"></a>    {
<a name="line1589"></a>        $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode');
<a name="line1590"></a>
<a name="line1591"></a>        if (Auth_OpenID::isFailure($mode)) {
<a name="line1592"></a>            return new Auth_OpenID_ServerError($message,
<a name="line1593"></a>                                               $mode->message);
<a name="line1594"></a>        }
<a name="line1595"></a>
<a name="line1596"></a>        return new Auth_OpenID_ServerError($message,
<a name="line1597"></a>                       sprintf("Unrecognized OpenID mode %s", $mode));
<a name="line1598"></a>    }
<a name="line1599"></a>}
<a name="line1600"></a>
<a name="line1601"></a>/**
<a name="line1602"></a> * An error that indicates an encoding problem occurred.
<a name="line1603"></a> *
<a name="line1604"></a> * @package OpenID
<a name="line1605"></a> */
<a name="line1606"></a>class Auth_OpenID_EncodingError {
<a name="line1607"></a>    function Auth_OpenID_EncodingError($response)
<a name="line1608"></a>    {
<a name="line1609"></a>        $this->response = $response;
<a name="line1610"></a>    }
<a name="line1611"></a>}
<a name="line1612"></a>
<a name="line1613"></a>/**
<a name="line1614"></a> * An error that indicates that a response was already signed.
<a name="line1615"></a> *
<a name="line1616"></a> * @package OpenID
<a name="line1617"></a> */
<a name="line1618"></a>class Auth_OpenID_AlreadySigned extends Auth_OpenID_EncodingError {
<a name="line1619"></a>    // This response is already signed.
<a name="line1620"></a>}
<a name="line1621"></a>
<a name="line1622"></a>/**
<a name="line1623"></a> * An error that indicates that the given return_to is not under the
<a name="line1624"></a> * given trust_root.
<a name="line1625"></a> *
<a name="line1626"></a> * @package OpenID
<a name="line1627"></a> */
<a name="line1628"></a>class Auth_OpenID_UntrustedReturnURL extends Auth_OpenID_ServerError {
<a name="line1629"></a>    function Auth_OpenID_UntrustedReturnURL($message, $return_to,
<a name="line1630"></a>                                            $trust_root)
<a name="line1631"></a>    {
<a name="line1632"></a>        parent::Auth_OpenID_ServerError($message, "Untrusted return_to URL");
<a name="line1633"></a>        $this->return_to = $return_to;
<a name="line1634"></a>        $this->trust_root = $trust_root;
<a name="line1635"></a>    }
<a name="line1636"></a>
<a name="line1637"></a>    function toString()
<a name="line1638"></a>    {
<a name="line1639"></a>        return sprintf("return_to %s not under trust_root %s",
<a name="line1640"></a>                       $this->return_to, $this->trust_root);
<a name="line1641"></a>    }
<a name="line1642"></a>}
<a name="line1643"></a>
<a name="line1644"></a>/**
<a name="line1645"></a> * I handle requests for an OpenID server.
<a name="line1646"></a> *
<a name="line1647"></a> * Some types of requests (those which are not checkid requests) may
<a name="line1648"></a> * be handed to my {@link handleRequest} method, and I will take care
<a name="line1649"></a> * of it and return a response.
<a name="line1650"></a> *
<a name="line1651"></a> * For your convenience, I also provide an interface to {@link
<a name="line1652"></a> * Auth_OpenID_Decoder::decode()} and {@link
<a name="line1653"></a> * Auth_OpenID_SigningEncoder::encode()} through my methods {@link
<a name="line1654"></a> * decodeRequest} and {@link encodeResponse}.
<a name="line1655"></a> *
<a name="line1656"></a> * All my state is encapsulated in an {@link Auth_OpenID_OpenIDStore}.
<a name="line1657"></a> *
<a name="line1658"></a> * Example:
<a name="line1659"></a> *
<a name="line1660"></a> * <pre> $oserver = new Auth_OpenID_Server(Auth_OpenID_FileStore($data_path),
<a name="line1661"></a> *                                   "http://example.com/op");
<a name="line1662"></a> * $request = $oserver->decodeRequest();
<a name="line1663"></a> * if (in_array($request->mode, array('checkid_immediate',
<a name="line1664"></a> *                                    'checkid_setup'))) {
<a name="line1665"></a> *     if ($app->isAuthorized($request->identity, $request->trust_root)) {
<a name="line1666"></a> *         $response = $request->answer(true);
<a name="line1667"></a> *     } else if ($request->immediate) {
<a name="line1668"></a> *         $response = $request->answer(false);
<a name="line1669"></a> *     } else {
<a name="line1670"></a> *         $app->showDecidePage($request);
<a name="line1671"></a> *         return;
<a name="line1672"></a> *     }
<a name="line1673"></a> * } else {
<a name="line1674"></a> *     $response = $oserver->handleRequest($request);
<a name="line1675"></a> * }
<a name="line1676"></a> *
<a name="line1677"></a> * $webresponse = $oserver->encode($response);</pre>
<a name="line1678"></a> *
<a name="line1679"></a> * @package OpenID
<a name="line1680"></a> */
<a name="line1681"></a>class Auth_OpenID_Server {
<a name="line1682"></a>    function Auth_OpenID_Server($store, $op_endpoint=null)
<a name="line1683"></a>    {
<a name="line1684"></a>        $this->store = $store;
<a name="line1685"></a>        $this->signatory = new Auth_OpenID_Signatory($this->store);
<a name="line1686"></a>        $this->encoder = new Auth_OpenID_SigningEncoder($this->signatory);
<a name="line1687"></a>        $this->decoder = new Auth_OpenID_Decoder($this);
<a name="line1688"></a>        $this->op_endpoint = $op_endpoint;
<a name="line1689"></a>        $this->negotiator = Auth_OpenID_getDefaultNegotiator();
<a name="line1690"></a>    }
<a name="line1691"></a>
<a name="line1692"></a>    /**
<a name="line1693"></a>     * Handle a request.  Given an {@link Auth_OpenID_Request} object,
<a name="line1694"></a>     * call the appropriate {@link Auth_OpenID_Server} method to
<a name="line1695"></a>     * process the request and generate a response.
<a name="line1696"></a>     *
<a name="line1697"></a>     * @param Auth_OpenID_Request $request An {@link Auth_OpenID_Request}
<a name="line1698"></a>     * returned by {@link Auth_OpenID_Server::decodeRequest()}.
<a name="line1699"></a>     *
<a name="line1700"></a>     * @return Auth_OpenID_ServerResponse $response A response object
<a name="line1701"></a>     * capable of generating a user-agent reply.
<a name="line1702"></a>     */
<a name="line1703"></a>    function handleRequest($request)
<a name="line1704"></a>    {
<a name="line1705"></a>        if (method_exists($this, "openid_" . $request->mode)) {
<a name="line1706"></a>            $handler = array($this, "openid_" . $request->mode);
<a name="line1707"></a>            return call_user_func($handler, &$request);
<a name="line1708"></a>        }
<a name="line1709"></a>        return null;
<a name="line1710"></a>    }
<a name="line1711"></a>
<a name="line1712"></a>    /**
<a name="line1713"></a>     * The callback for 'check_authentication' messages.
<a name="line1714"></a>     */
<a name="line1715"></a>    function openid_check_authentication($request)
<a name="line1716"></a>    {
<a name="line1717"></a>        return $request->answer($this->signatory);
<a name="line1718"></a>    }
<a name="line1719"></a>
<a name="line1720"></a>    /**
<a name="line1721"></a>     * The callback for 'associate' messages.
<a name="line1722"></a>     */
<a name="line1723"></a>    function openid_associate($request)
<a name="line1724"></a>    {
<a name="line1725"></a>        $assoc_type = $request->assoc_type;
<a name="line1726"></a>        $session_type = $request->session->session_type;
<a name="line1727"></a>        if ($this->negotiator->isAllowed($assoc_type, $session_type)) {
<a name="line1728"></a>            $assoc = $this->signatory->createAssociation(false,
<a name="line1729"></a>                                                         $assoc_type);
<a name="line1730"></a>            return $request->answer($assoc);
<a name="line1731"></a>        } else {
<a name="line1732"></a>            $message = sprintf('Association type %s is not supported with '.
<a name="line1733"></a>                               'session type %s', $assoc_type, $session_type);
<a name="line1734"></a>            list($preferred_assoc_type, $preferred_session_type) =
<a name="line1735"></a>                $this->negotiator->getAllowedType();
<a name="line1736"></a>            return $request->answerUnsupported($message,
<a name="line1737"></a>                                               $preferred_assoc_type,
<a name="line1738"></a>                                               $preferred_session_type);
<a name="line1739"></a>        }
<a name="line1740"></a>    }
<a name="line1741"></a>
<a name="line1742"></a>    /**
<a name="line1743"></a>     * Encodes as response in the appropriate format suitable for
<a name="line1744"></a>     * sending to the user agent.
<a name="line1745"></a>     */
<a name="line1746"></a>    function encodeResponse($response)
<a name="line1747"></a>    {
<a name="line1748"></a>        return $this->encoder->encode($response);
<a name="line1749"></a>    }
<a name="line1750"></a>
<a name="line1751"></a>    /**
<a name="line1752"></a>     * Decodes a query args array into the appropriate
<a name="line1753"></a>     * {@link Auth_OpenID_Request} object.
<a name="line1754"></a>     */
<a name="line1755"></a>    function decodeRequest($query=null)
<a name="line1756"></a>    {
<a name="line1757"></a>        if ($query === null) {
<a name="line1758"></a>            $query = Auth_OpenID::getQuery();
<a name="line1759"></a>        }
<a name="line1760"></a>
<a name="line1761"></a>        return $this->decoder->decode($query);
<a name="line1762"></a>    }
<a name="line1763"></a>}
<a name="line1764"></a>
<a name="line1765"></a>
<a name="line1766"></a></pre>
<div class="header">
<h1>GiftFlow API</h1>
<ul>
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li>Package</li><li>Class</li><li>Tree</li><li><a href="../../../../overview-files.html">Files</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
</ul>
</div>

<div class="small_links">
<a href="../../../../index.html" target="_top">Frames</a>
<a href="../../../../source/libraries/auth/openid/server.php.html" target="_top">No frames</a>
</div>
<hr>

<p id="footer">This document was generated by <a href="http://peej.github.com/phpdoctor/">PHPDoctor: The PHP Documentation Creator</a></p>

</body>

</html>